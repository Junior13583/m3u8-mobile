<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title></title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            justify-content: center;
        }
        .list {
            width: 600px;
            margin-top: 100px;
        }
        .list-item {
            margin: 6px 0;
            padding: 0 20px;
            line-height: 40px;
            height: 40px;
            background: #409eff;
            color: #fff;
            text-align: center;
            cursor: move;
            user-select: none;
            border-radius: 5px;
        }
        .list-item.moving {
            background: transparent;
            color: transparent;
            border: 1px dashed #ccc;
        }
    </style>
</head>
<body>
<div class="list">
    <div draggable="true" class="list-item">1</div>
    <div draggable="true" class="list-item">2</div>
    <div draggable="true" class="list-item">3</div>
    <div draggable="true" class="list-item">4</div>
    <div draggable="true" class="list-item">5</div>
    <div draggable="true" class="list-item">6</div>
</div>
</body>
<script src="static/js/flip.js"></script>
<script>
    const list = document.querySelector('.list');
    // 记录被拖拽的元素
    let sourceNode;
    let flip;

    list.ondragstart = (e) => {
        setTimeout(() => {
            e.target.classList.add('moving')
        }, 0)
        sourceNode = e.target;
        flip = new Flip(list.children, 0.5);
    }

    list.ondragover = (e) => {
        e.preventDefault();
    }

    list.ondragenter = e => {
        e.preventDefault();
        // 判断拖拽元素进入的元素等于父元素list或等于拖拽元素本身，
        // 不做受任何处理，直接结束
        if(e.target === list || e.target === sourceNode) {
            return;
        }
        // 判断元素拖拽进入的位置是在目标的上面还是下面，
        // 比如拖动3进入到4时，4要移动到上面，
        // 当拖动3进入到2时，2要移动到下面，
        // 通过元素所处的下表既可判断。

        // 首先，拿到元素list所有的子元素
        const children = [...list.children];
        // 接着，拿到要拖拽元素在整个子元素里面的下标
        const sourceIndex = children.indexOf(sourceNode);
        // 然后，拿到要进入目标元素在整个子元素里面的下标
        const targetIndex = children.indexOf(e.target);
        if(sourceIndex < targetIndex) {
            // 进入目标元素大于拖拽元素的下标，
            // 此时要插入目标元素的下方位置，
            // 也就是目标元素下一个元素的前面
            list.insertBefore(sourceNode, e.target.nextElementSibling);
        } else {
            // 进入目标元素小于拖拽元素的下标，
            // 此时要插入目标元素的上方位置，
            // 也就是目标元素前面的位置
            list.insertBefore(sourceNode, e.target);
        }
        // 调用flip动画play方法
        flip.play();
    }

    list.ondragend = () => {
        sourceNode.classList.remove('moving');
    }
</script>
</html>